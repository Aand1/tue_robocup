[ERROR] [WallTime: 1437231379.268721] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231379.494643] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231379.495192] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231379.549522] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231379.549994] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231379.550345] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231379.552425] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231379.783837] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231379.784525] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231379.843721] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231379.844225] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231379.844588] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231379.846781] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231380.073854] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231380.074691] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231380.127563] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231380.128103] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231380.128485] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231380.130627] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231380.356664] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231380.357238] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231380.425645] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231380.426180] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231380.426585] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231380.428776] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231380.651639] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231380.652347] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231380.720664] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231380.721208] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231380.721617] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231380.724023] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231380.952492] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231380.953243] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231381.027106] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231381.027665] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231381.028059] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231381.030240] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231381.256918] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231381.257538] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231381.324532] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231381.325052] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231381.325445] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231381.327866] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231381.528327] State machine transitioning 'LOOK_IF_AWAKE':'not_there'-->'CHECK_TIME'
[INFO] [WallTime: 1437231381.528888] State machine transitioning 'CHECK_TIME':'ok'-->'WAKEUP_MESSAGE'
[INFO] [WallTime: 1437231381.529366] 'Hello there sleepy head! Please get up'
[INFO] [WallTime: 1437231384.601745] State machine transitioning 'WAKEUP_MESSAGE':'spoken'-->'LOOK_IF_AWAKE'
[INFO] [WallTime: 1437231384.628836] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231384.629443] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231384.674774] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231384.675364] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231384.675878] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231384.678019] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231384.902125] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231384.902719] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231384.951804] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231384.952347] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231384.952725] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231384.955054] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231385.180529] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231385.181143] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231385.226293] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231385.226788] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231385.227145] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231385.229294] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231385.453114] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231385.453781] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231385.500661] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231385.501127] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231385.501481] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231385.503959] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231385.719847] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231385.720471] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231385.767860] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231385.768447] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231385.768892] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231385.771066] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231385.989378] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231385.989946] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231386.036403] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231386.036986] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231386.037393] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231386.039546] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231386.263744] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231386.264308] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231386.319217] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231386.319717] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231386.320088] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231386.322262] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231386.547480] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231386.548055] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231386.595368] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231386.595828] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231386.596175] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231386.598443] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231386.820345] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231386.820913] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231386.866135] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231386.866593] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231386.866944] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231386.869071] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231387.086098] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231387.086742] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231387.143272] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231387.143858] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231387.144245] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231387.146584] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231387.374854] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231387.375676] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231387.418756] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231387.419227] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231387.419584] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231387.421736] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231387.648811] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231387.649396] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231387.695301] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231387.695826] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231387.696698] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231387.699600] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231387.923196] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231387.923820] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231387.968252] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231387.968753] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231387.969128] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231387.971318] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231388.198336] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231388.199032] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231388.253907] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231388.254386] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231388.254739] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231388.256971] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231388.479570] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231388.480204] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231388.537743] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231388.538277] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231388.538656] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231388.540977] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231388.764283] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231388.764900] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231388.815426] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231388.815982] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231388.816355] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231388.818476] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231389.036682] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437231389.037341] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231389.082705] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231389.083228] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231389.083634] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231389.086067] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231389.309956] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231389.310547] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437231389.351404] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231389.351977] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231389.352349] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231389.354591] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231389.580612] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 6 entities
[INFO] [WallTime: 1437231389.581304] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231389.635273] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437231389.635800] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437231389.636161] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437231389.638336] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437231389.838898] State machine transitioning 'LOOK_IF_AWAKE':'not_there'-->'CHECK_TIME'
[INFO] [WallTime: 1437231389.839425] State machine transitioning 'CHECK_TIME':'ok'-->'WAKEUP_MESSAGE'
[INFO] [WallTime: 1437231389.839890] 'Rise and shine'
[INFO] [WallTime: 1437231391.242736] State machine transitioning 'WAKEUP_MESSAGE':'spoken'-->'LOOK_IF_AWAKE'
[INFO] [WallTime: 1437231391.265572] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 5 entities
[INFO] [WallTime: 1437231391.266145] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 5 entities
[INFO] [WallTime: 1437231391.343672] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + bed.z_max + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 1 entities
[INFO] [WallTime: 1437231391.344222] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 1 entities
[INFO] [WallTime: 1437231391.344759] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 1 entities
[INFO] [WallTime: 1437231391.345070] choosing best entity from this list (name->weight):
    [('924336315f27a41746037804635c525e', 0)]
[INFO] [WallTime: 1437231391.426423] State machine transitioning 'LOOK_IF_AWAKE':'there'-->'SAY_AWAKE'
[INFO] [WallTime: 1437231391.427056] 'Finally, you're awake, I will hand you your newspaper now'
[INFO] [WallTime: 1437231395.534927] State machine transitioning 'SAY_AWAKE':'spoken'-->'HANDOVER_NEWSPAPER'
[INFO] [WallTime: 1437231395.535573] State machine starting in initial state 'LOCK_ARM' with userdata: 
    []
[INFO] [WallTime: 1437231395.535930] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fccaf687ed0>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437231395.536337] LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fccaf687ed0>)) locked to <robot_ski
[INFO] [WallTime: 1437231395.536581] locking_designator LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fccaf687ed0>)) is now locked to <robot_ski
[INFO] [WallTime: 1437231395.536813] State machine transitioning 'LOCK_ARM':'locked'-->'SPINDLE_MEDIUM'
[INFO] [WallTime: 1437231395.537396] State machine transitioning 'SPINDLE_MEDIUM':'done'-->'MOVE_HUMAN_HANDOVER_JOINT_GOAL'
[INFO] [WallTime: 1437231398.359238] State machine transitioning 'MOVE_HUMAN_HANDOVER_JOINT_GOAL':'succeeded'-->'SAY_OPEN_GRIPPER'
[INFO] [WallTime: 1437231398.359852] 'I will open my gripper when you slightly pull this thing'
[INFO] [WallTime: 1437231401.817346] State machine transitioning 'SAY_OPEN_GRIPPER':'spoken'-->'OPEN_GRIPPER_ON_HANDOVER'
[INFO] [WallTime: 1437231431.829570] State machine transitioning 'OPEN_GRIPPER_ON_HANDOVER':'failed'-->'SAY_I_WILL_KEEP_IT'
[INFO] [WallTime: 1437231431.830161] 'If you don't want it, I will keep it'
[INFO] [WallTime: 1437231434.388824] State machine transitioning 'SAY_I_WILL_KEEP_IT':'spoken'-->'RESET_ARM'
[INFO] [WallTime: 1437231437.210760] State machine transitioning 'RESET_ARM':'succeeded'-->'RESET_TORSO'
[INFO] [WallTime: 1437231437.211688] State machine transitioning 'RESET_TORSO':'done'-->'UNLOCK_ARM'
[INFO] [WallTime: 1437231437.212155] locking_designator LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fccaf687ed0>)) is going to unlock from <robot_ski
[INFO] [WallTime: 1437231437.212509] State machine terminating 'UNLOCK_ARM':'unlocked':'succeeded'
[INFO] [WallTime: 1437231437.212939] State machine terminating 'HANDOVER_NEWSPAPER':'succeeded':'container_succeeded'
[INFO] [WallTime: 1437231437.213225] State machine transitioning 'WAKEUP_CONTAINER':'container_succeeded'-->'CANCEL_HEAD_GOALS_1'
[WAKE ME UP] CancelHeadGoals
[INFO] [WallTime: 1437231437.213618] State machine transitioning 'CANCEL_HEAD_GOALS_1':'done'-->'TAKE_ORDER_CONTAINER'
[INFO] [WallTime: 1437231437.213988] State machine starting in initial state 'SET_TIME_MARKER' with userdata: 
    []
[INFO] [WallTime: 1437231437.214921] State machine transitioning 'SET_TIME_MARKER':'done'-->'SAY_WHAT_BREAKFAST'
[INFO] [WallTime: 1437231437.215307] 'What would you like to have for breakfast?'
[INFO] [WallTime: 1437231439.517525] State machine transitioning 'SAY_WHAT_BREAKFAST':'spoken'-->'GET_ORDER'
[WAKE ME UP] GetOrder
[WAKE ME UP] KeyError resolving: 'beginning'
[WAKE ME UP] KeyError resolving: 'preposition'
[WAKE ME UP] What was heard:      papaya_milk
[WAKE ME UP] Could not get a match with word_item1 = 
[WAKE ME UP] Could not get a match with word_item2 = 
[WAKE ME UP] Third item Milk
[WAKE ME UP] Response: fruit = lemon, cereal = egg_stars , milk = papaya_milk
[INFO] [WallTime: 1437231446.195069] State machine transitioning 'GET_ORDER':'succeeded'-->'SAY_REPEAT_ORDER'
[WAKE ME UP] RepeatOrderToPerson
[INFO] [WallTime: 1437231446.195673] 'I will get you a lemon and egg stars with papaya milk. Breakfast will be served in the dining room.'
[INFO] [WallTime: 1437231446.198380] State machine terminating 'SAY_REPEAT_ORDER':'done':'container_succeeded'
[INFO] [WallTime: 1437231446.198783] State machine transitioning 'TAKE_ORDER_CONTAINER':'container_succeeded'-->'GOTO_KITCHEN_CONTAINER'
[INFO] [WallTime: 1437231446.199214] State machine starting in initial state 'SAY_PREPARING' with userdata: 
    []
[INFO] [WallTime: 1437231446.199629] 'I'm going to the kitchen'
[INFO] [WallTime: 1437231446.201935] State machine transitioning 'SAY_PREPARING':'spoken'-->'GOTO_KITCHEN'
[INFO] [WallTime: 1437231446.202416] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437231446.208234] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437231446.208706] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437231446.319700] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437231446.413597] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437231446.435580] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fccaf558170>
[INFO] [WallTime: 1437231446.435988] 'Getting there!'
[INFO] [WallTime: 1437231446.438752] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437231468.461685] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437231468.462292] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437231468.466786] 

Navigation summary:
Covered 8.23349613561 meters in 22.258428812 seconds (0.369904641749) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437231468.467161] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437231468.467457] State machine terminating 'GOTO_KITCHEN':'arrived':'container_succeeded'
[INFO] [WallTime: 1437231468.467713] State machine transitioning 'GOTO_KITCHEN_CONTAINER':'container_succeeded'-->'PREP_BREAKFAST_CONTAINER'
[INFO] [WallTime: 1437231468.468101] State machine starting in initial state 'SAY_PREPARING' with userdata: 
    []
[INFO] [WallTime: 1437231468.468474] 'I'm going to prepare your breakfast. La la la la la'
[INFO] [WallTime: 1437231468.470946] State machine transitioning 'SAY_PREPARING':'spoken'-->'SELECT_ITEM'
[INFO] [WallTime: 1437231468.471508] 'I will get your milk now.'
[INFO] [WallTime: 1437231468.473848] State machine transitioning 'SELECT_ITEM':'selected'-->'GOTO_ITEM'
[INFO] [WallTime: 1437231468.474252] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437231468.477312] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437231468.477784] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437231468.594241] choosing best entity from this list (name->weight):
    [('kitchentable', 0)]
[INFO] [WallTime: 1437231468.601358] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437231468.709296] choosing best entity from this list (name->weight):
    [('kitchentable', 0)]
[INFO] [WallTime: 1437231468.729963] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fccaf558dd0>
[INFO] [WallTime: 1437231468.730405] 'Getting there!'
[INFO] [WallTime: 1437231468.733158] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[ERROR] [WallTime: 1437231468.783674] Received comm state RECALLING when in simple state DONE with SimpleActionClient in NS /amigo/head_ref/action_server
[INFO] [WallTime: 1437231478.742763] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437231478.743474] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437231478.747426] 

Navigation summary:
Covered 1.98193735562 meters in 10.2699649334 seconds (0.192983848385) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437231478.747793] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437231478.748091] State machine transitioning 'GOTO_ITEM':'arrived'-->'FIND_ITEM'
[INFO] [WallTime: 1437231478.760601] choosing best entity from this list (name->weight):
    [('kitchentable', 0)]
[INFO] [WallTime: 1437231478.760905] Look at x: 0.0 y: 0.0 z: 0.769999980927 in frame /kitchentable
I found the following items: ['coco_balls', 'apple']
[INFO] [WallTime: 1437231483.083648] State machine transitioning 'FIND_ITEM':'not_found'-->'SAY_ITEM_NOT_FOUND'
[INFO] [WallTime: 1437231483.084283] 'Oops, I can't find the item'
[INFO] [WallTime: 1437231485.513315] State machine transitioning 'SAY_ITEM_NOT_FOUND':'spoken'-->'SELECT_ITEM'
[INFO] [WallTime: 1437231485.513929] 'I will get your fruit now.'
[INFO] [WallTime: 1437231485.516695] State machine transitioning 'SELECT_ITEM':'selected'-->'GOTO_ITEM'
[INFO] [WallTime: 1437231485.517145] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437231485.520287] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437231485.520722] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437231485.636587] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437231485.645718] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437231485.710686] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437231485.731502] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fccaf5d3ef0>
[INFO] [WallTime: 1437231485.732208] 'I'm on my way!'
[INFO] [WallTime: 1437231485.735024] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437231496.745993] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437231496.746408] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437231496.749655] 

Navigation summary:
Covered 1.92935859013 meters in 11.2292840481 seconds (0.171814924431) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437231496.750004] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437231496.750320] State machine transitioning 'GOTO_ITEM':'arrived'-->'FIND_ITEM'
[INFO] [WallTime: 1437231496.757486] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437231496.757852] Look at x: 0.0 y: 0.0 z: 0.735000014305 in frame /kitchencounter
I found the following items: ['coconut_cereals']
[INFO] [WallTime: 1437231501.198830] State machine transitioning 'FIND_ITEM':'not_found'-->'SAY_ITEM_NOT_FOUND'
[INFO] [WallTime: 1437231501.199495] 'Oops, I can't find the item'
[INFO] [WallTime: 1437231503.629750] State machine transitioning 'SAY_ITEM_NOT_FOUND':'spoken'-->'SELECT_ITEM'
[INFO] [WallTime: 1437231503.630697] 'I will get your cereal now.'
[INFO] [WallTime: 1437231503.634023] State machine transitioning 'SELECT_ITEM':'selected'-->'GOTO_ITEM'
[INFO] [WallTime: 1437231503.634432] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437231503.637529] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437231503.638002] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437231503.747256] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437231503.758777] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437231503.812401] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437231503.816081] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fccaf5d3320>
[INFO] [WallTime: 1437231503.816654] 'Getting there!'
[INFO] [WallTime: 1437231503.819823] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437231504.821634] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437231504.822106] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437231504.825608] 

Navigation summary:
Covered 0.0 meters in 1.18795800209 seconds (0.0) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437231504.825992] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437231504.826294] State machine transitioning 'GOTO_ITEM':'arrived'-->'FIND_ITEM'
[INFO] [WallTime: 1437231504.840985] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437231504.841314] Look at x: 0.0 y: 0.0 z: 0.735000014305 in frame /kitchencounter
I found the following items: ['coconut_cereals']
[ERROR] [WallTime: 1437231507.955347] InvalidUserCodeError: Could not execute state 'FIND_ITEM' of type '<wakemeup_states.FindItem object at 0x7fccaf6425d0>': Traceback (most recent call last):
  File "/opt/ros/indigo/lib/python2.7/dist-packages/smach/state_machine.py", line 247, in _update_once
    self._remappings[self._current_label]))
  File "/home/amigo/ros/indigo/repos/https:/github.com/tue-robotics/tue_robocup.git/challenge_wakemeup/src/wakemeup_states.py", line 497, in execute
    result_des.current = self.robot.ed.get_entity(found_cereal[0])
NameError: global name 'result_des' is not defined

[ERROR] [WallTime: 1437231507.955844] State 'PREP_BREAKFAST_CONTAINER' failed to execute.
Exception occurred on state machine execution
