ROR] [WallTime: 1437384583.871701] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.019231619103
[INFO] [WallTime: 1437384584.096603] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384584.097208] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384584.143133] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384584.143648] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384584.144033] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384584.146528] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0248602028794
[INFO] [WallTime: 1437384584.371361] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384584.371929] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384584.405249] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384584.405775] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384584.406176] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384584.408634] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0304838155612
[INFO] [WallTime: 1437384584.628311] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384584.628856] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384584.676206] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384584.676683] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384584.677037] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384584.679488] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0527055934822
[INFO] [WallTime: 1437384584.902144] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384584.902720] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384584.938822] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384584.939475] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384584.939870] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384584.942485] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0372178639111
[INFO] [WallTime: 1437384585.165939] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384585.166571] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384585.211873] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384585.212381] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384585.212844] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384585.215193] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0484272330968
[INFO] [WallTime: 1437384585.443767] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384585.444295] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384585.477832] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384585.478366] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384585.478758] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384585.481038] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0275841565594
[INFO] [WallTime: 1437384585.704764] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384585.705625] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384585.742128] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384585.742693] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384585.743085] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384585.745889] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0256206752672
[INFO] [WallTime: 1437384585.973926] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384585.974548] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384586.007691] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384586.008195] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384586.008557] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384586.010880] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.0265749003702
[INFO] [WallTime: 1437384586.236929] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384586.237501] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437384586.292142] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 1 entities
bed
[INFO] [WallTime: 1437384586.292742] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437384586.293176] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437384586.295519] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=['def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                print "this is true 3"\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n            print area\n\n            return area > knowledge.find_person[\'min_chull_area\']',
 'def probably_exists(entity):\n            print "This is true 2"\n            return entity.existence_probability > knowledge.find_person[\'min_exist_prob\']',
 'def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person[\'under_z\']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    print "this is true"\n                    return False\n\n            return True',
 'def is_not_bed(entity):\n            print entity.id\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            print entity.type\n            return entity.type == '' or entity.type == 'human'"])
3.30000007153
0.188000002325
0.188000002325
0.112670138368
[INFO] [WallTime: 1437384586.520417] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                print "this is true 3"
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2
            print area

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
This is true 2
This is true 2
This is true 2
This is true 2
[INFO] [WallTime: 1437384586.521004] Criterium         def probably_exists(entity):
            print "This is true 2"
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437384586.578401] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    print "this is true"
                    return False

            return True
 leaves 2 entities
bed
d53f31bb4bb97e03956a5e35a47bf7bc-laser
[INFO] [WallTime: 1437384586.578946] Criterium         def is_not_bed(entity):
            print entity.id
            return entity.id != knowledge.bed
 leaves 1 entities

[INFO] [WallTime: 1437384586.579383] Criterium         def is_not_prior(entity):
            print entity.type
            return entity.type == '' or entity.type == 'human'
 leaves 1 entities
[INFO] [WallTime: 1437384586.579728] choosing best entity from this list (name->weight):
    [('d53f31bb4bb97e03956a5e35a47bf7bc-laser', 0)]
[INFO] [WallTime: 1437384586.580337] State machine transitioning 'LOOK_IF_AWAKE':'there'-->'SAY_AWAKE'
[INFO] [WallTime: 1437384586.580763] 'Finally, you're awake. Now please face me. I will hand you your newspaper now'
[INFO] [WallTime: 1437384586.583527] State machine transitioning 'SAY_AWAKE':'spoken'-->'HANDOVER_NEWSPAPER'
[INFO] [WallTime: 1437384586.583994] State machine starting in initial state 'LOCK_ARM' with userdata: 
    []
[INFO] [WallTime: 1437384586.584310] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7f6f98fb8f90>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437384586.584599] LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7f6f98fb8f90>)) locked to <robot_ski
[INFO] [WallTime: 1437384586.584834] locking_designator LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7f6f98fb8f90>)) is now locked to <robot_ski
[INFO] [WallTime: 1437384586.585054] State machine transitioning 'LOCK_ARM':'locked'-->'SPINDLE_MEDIUM'
[INFO] [WallTime: 1437384586.585942] State machine transitioning 'SPINDLE_MEDIUM':'done'-->'MOVE_HUMAN_HANDOVER_JOINT_GOAL'
[INFO] [WallTime: 1437384589.407171] State machine transitioning 'MOVE_HUMAN_HANDOVER_JOINT_GOAL':'succeeded'-->'SAY_OPEN_GRIPPER'
[INFO] [WallTime: 1437384589.407833] 'Please take it from my gripper'
[INFO] [WallTime: 1437384594.885509] State machine transitioning 'SAY_OPEN_GRIPPER':'spoken'-->'OPEN_GRIPPER_ON_HANDOVER'
/amigo/handoverdetector_right/result
[INFO] [WallTime: 1437384597.224036] State machine transitioning 'OPEN_GRIPPER_ON_HANDOVER':'succeeded'-->'CLOSE_GRIPPER_HANDOVER'
[INFO] [WallTime: 1437384597.224702] State machine transitioning 'CLOSE_GRIPPER_HANDOVER':'succeeded'-->'RESET_ARM'
[INFO] [WallTime: 1437384600.046306] State machine transitioning 'RESET_ARM':'succeeded'-->'RESET_TORSO'
[INFO] [WallTime: 1437384600.047233] State machine transitioning 'RESET_TORSO':'done'-->'UNLOCK_ARM'
[INFO] [WallTime: 1437384600.049599] locking_designator LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7f6f98fb8f90>)) is going to unlock from <robot_ski
[INFO] [WallTime: 1437384600.049928] State machine terminating 'UNLOCK_ARM':'unlocked':'succeeded'
[INFO] [WallTime: 1437384600.050220] State machine terminating 'HANDOVER_NEWSPAPER':'succeeded':'container_succeeded'
[INFO] [WallTime: 1437384600.050511] State machine transitioning 'WAKEUP_CONTAINER':'container_succeeded'-->'CANCEL_HEAD_GOALS_1'
[WAKE ME UP] CancelHeadGoals
[INFO] [WallTime: 1437384600.051009] State machine transitioning 'CANCEL_HEAD_GOALS_1':'done'-->'RECONFIGURE_ED2'
[INFO] [WallTime: 1437384601.107281] State machine transitioning 'RECONFIGURE_ED2':'done'-->'TAKE_ORDER_CONTAINER'
[INFO] [WallTime: 1437384601.108119] State machine starting in initial state 'COUNTER' with userdata: 
    []
[INFO] [WallTime: 1437384601.108454] State machine transitioning 'COUNTER':'counted'-->'SAY_WHAT_BREAKFAST'
[INFO] [WallTime: 1437384601.108903] 'Please tell me your breakfast order.'
[INFO] [WallTime: 1437384603.411864] State machine transitioning 'SAY_WHAT_BREAKFAST':'spoken'-->'GET_ORDER'
[WAKE ME UP] GetOrder
^C[ERROR] [WallTime: 1437384605.791164] InvalidUserCodeError: Could not execute state 'GET_ORDER' of type '<wakemeup_states.GetOrder object at 0x7f6f98f58b50>': Traceback (most recent call last):
  File "/opt/ros/indigo/lib/python2.7/dist-packages/smach/state_machine.py", line 247, in _update_once
    self._remappings[self._current_label]))
  File "/home/amigo/ros/indigo/repos/https:/github.com/tue-robotics/tue_robocup.git/challenge_wakemeup/src/wakemeup_states.py", line 180, in execute
    outcome = state.execute()
  File "/home/amigo/ros/indigo/system/src/robot_smach_states/src/robot_smach_states/human_interaction/human_interaction.py", line 182, in execute
    answer = self.robot.ears.recognize(spec, choices, self.time_out)
  File "/home/amigo/ros/indigo/system/src/robot_skills/src/robot_skills/ears.py", line 34, in recognize
    answer = self._get_speech_client_service(req)
  File "/opt/ros/indigo/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py", line 435, in __call__
    return self.call(*args, **kwds)
  File "/opt/ros/indigo/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py", line 523, in call
    raise rospy.exceptions.ROSInterruptException("node shutdown interrupted service call")
ROSInterruptException: node shutdown interrupted service call

[ERROR] [WallTime: 1437384605.791461] State 'TAKE_ORDER_CONTAINER' failed to execute.
Exception occurred on state machine execution

