rea > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375142.923294] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375142.956725] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375142.957231] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375142.957593] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375142.959803] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375143.180777] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375143.181291] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375143.217086] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375143.217660] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375143.218048] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375143.220334] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375143.448161] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375143.448911] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375143.492847] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375143.493339] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375143.493702] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375143.495829] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375143.722415] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375143.722935] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375143.757139] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375143.757655] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375143.758033] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375143.760360] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375143.987393] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375143.988015] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375144.022752] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375144.023267] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375144.023621] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375144.025744] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375144.250950] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375144.251463] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375144.285383] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375144.285938] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375144.286309] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375144.288418] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375144.508303] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375144.509011] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375144.544966] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375144.545445] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375144.545849] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375144.548099] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375144.776864] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375144.777435] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375144.812310] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375144.813119] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375144.813457] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375144.816157] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375145.038469] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375145.039025] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375145.075371] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375145.075896] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375145.076307] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375145.078454] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375145.303165] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375145.303972] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375145.341391] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375145.341932] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375145.342345] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375145.344714] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375145.565376] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375145.565962] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375145.600916] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375145.601428] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375145.601787] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375145.604085] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375145.823649] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375145.824175] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375145.858210] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375145.858703] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375145.859130] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375145.861605] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375146.062234] State machine transitioning 'LOOK_IF_AWAKE':'not_there'-->'CHECK_TIME'
[INFO] [WallTime: 1437375146.062707] State machine transitioning 'CHECK_TIME':'ok'-->'WAKEUP_MESSAGE'
[INFO] [WallTime: 1437375146.063058] 'Wake up boss'
[INFO] [WallTime: 1437375146.066027] State machine transitioning 'WAKEUP_MESSAGE':'spoken'-->'LOOK_IF_AWAKE'
[INFO] [WallTime: 1437375146.091183] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375146.091718] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375146.126469] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375146.126955] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375146.127313] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375146.130008] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375146.353951] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375146.354459] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375146.389541] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375146.390070] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375146.390419] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375146.392524] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375146.622174] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375146.622687] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375146.656446] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375146.656926] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375146.657255] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375146.659394] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375146.888115] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375146.888674] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375146.935249] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375146.935741] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375146.936101] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375146.938370] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375147.163456] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375147.164016] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375147.199249] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375147.199750] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375147.200097] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375147.202260] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375147.428350] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375147.428901] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375147.461116] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375147.461588] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375147.461948] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375147.464164] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375147.679665] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375147.680375] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375147.715405] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375147.715867] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375147.716221] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375147.718514] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375147.937013] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375147.937514] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375147.981224] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375147.981702] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375147.982052] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375147.984165] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375148.210457] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375148.210988] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375148.256965] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375148.257504] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375148.257868] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375148.260158] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375148.485776] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375148.486345] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375148.532452] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375148.532909] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375148.533250] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375148.535820] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375148.760357] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375148.760875] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375148.795235] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375148.795745] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375148.796122] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375148.798309] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375149.025511] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375149.026127] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375149.059065] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375149.059589] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375149.059986] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375149.062568] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375149.287653] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375149.288215] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375149.323214] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375149.323700] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375149.324035] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375149.326237] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375149.551851] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 3 entities
[INFO] [WallTime: 1437375149.552354] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 3 entities
[INFO] [WallTime: 1437375149.587264] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 0 entities
[INFO] [WallTime: 1437375149.587798] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 0 entities
[INFO] [WallTime: 1437375149.588171] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 0 entities
[ERROR] [WallTime: 1437375149.590320] No entities found in EdEntityDesignator(robot, type=, center_point=x: 10.535 y: -8.15 z: 0.0, radius=2.0, id=, parse=True, criteriafuncs=["def is_large_enough(entity):\n            if len(entity.convex_hull) < 3:\n                return False\n\n            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]\n            area = 0\n            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):\n                area += pt.x*( npt.y - ppt.y );\n            area /= 2\n\n            return area > knowledge.find_person['min_chull_area']",
 "def probably_exists(entity):\n            return entity.existence_probability > knowledge.find_person['min_exist_prob']",
 "def is_just_above_bed(entity):\n            bed = robot.ed.get_entity(knowledge.bed)\n\n            # Check if top of found object is above a certain threshold above the bed\n            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:\n                return False\n\n            # Check if center point of entity is within chull of bed\n            bed_chull = bed.convex_hull\n            bed_chull = bed_chull + [bed_chull[0]]\n\n            for i in range(len(bed_chull)-1):\n                dx = bed_chull[i+1].x - bed_chull[i].x\n                dy = bed_chull[i+1].y - bed_chull[i].y\n\n                dxe = -bed_chull[i].x\n                dye = -bed_chull[i].y\n\n                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull\n                if dx*dye-dy*dxe < 0:\n                    return False\n\n            return True",
 'def is_not_bed(entity):\n            return entity.id != knowledge.bed',
 "def is_not_prior(entity):\n            return entity.type == '' or entity.type == 'human'"])
[INFO] [WallTime: 1437375149.804815] Criterium         def is_large_enough(entity):
            if len(entity.convex_hull) < 3:
                return False

            chull = [entity.convex_hull[-1]] + entity.convex_hull + [entity.convex_hull[0]]
            area = 0
            for ppt, pt, npt in zip(chull, chull[1:], chull[2:]):
                area += pt.x*( npt.y - ppt.y );
            area /= 2

            return area > knowledge.find_person['min_chull_area']
 leaves 4 entities
[INFO] [WallTime: 1437375149.805459] Criterium         def probably_exists(entity):
            return entity.existence_probability > knowledge.find_person['min_exist_prob']
 leaves 4 entities
[INFO] [WallTime: 1437375149.861743] Criterium         def is_just_above_bed(entity):
            bed = robot.ed.get_entity(knowledge.bed)

            # Check if top of found object is above a certain threshold above the bed
            if entity.pose.position.z + entity.z_max < bed.pose.position.z + knowledge.matress_height + knowledge.find_person['under_z']:
                return False

            # Check if center point of entity is within chull of bed
            bed_chull = bed.convex_hull
            bed_chull = bed_chull + [bed_chull[0]]

            for i in range(len(bed_chull)-1):
                dx = bed_chull[i+1].x - bed_chull[i].x
                dy = bed_chull[i+1].y - bed_chull[i].y

                dxe = -bed_chull[i].x
                dye = -bed_chull[i].y

                # Cross product of these two gives either positive or negative, if one is negative, point is outside the chull
                if dx*dye-dy*dxe < 0:
                    return False

            return True
 leaves 1 entities
[INFO] [WallTime: 1437375149.862287] Criterium         def is_not_bed(entity):
            return entity.id != knowledge.bed
 leaves 1 entities
[INFO] [WallTime: 1437375149.862701] Criterium         def is_not_prior(entity):
            return entity.type == '' or entity.type == 'human'
 leaves 1 entities
[INFO] [WallTime: 1437375149.862977] choosing best entity from this list (name->weight):
    [('05389e9d3f6f161941ec39300a641071-laser', 0)]
[INFO] [WallTime: 1437375149.863210] State machine transitioning 'LOOK_IF_AWAKE':'there'-->'SAY_AWAKE'
[INFO] [WallTime: 1437375149.863556] 'Finally, you're awake. Now please face me. I will hand you your newspaper now'
[INFO] [WallTime: 1437375149.865875] State machine transitioning 'SAY_AWAKE':'spoken'-->'HANDOVER_NEWSPAPER'
[INFO] [WallTime: 1437375149.866391] State machine starting in initial state 'LOCK_ARM' with userdata: 
    []
[INFO] [WallTime: 1437375149.866632] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375149.866833] LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>)) locked to <robot_ski
[INFO] [WallTime: 1437375149.867034] locking_designator LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>)) is now locked to <robot_ski
[INFO] [WallTime: 1437375149.867294] State machine transitioning 'LOCK_ARM':'locked'-->'SPINDLE_MEDIUM'
[INFO] [WallTime: 1437375149.867923] State machine transitioning 'SPINDLE_MEDIUM':'done'-->'MOVE_HUMAN_HANDOVER_JOINT_GOAL'
[INFO] [WallTime: 1437375152.687993] State machine transitioning 'MOVE_HUMAN_HANDOVER_JOINT_GOAL':'succeeded'-->'SAY_OPEN_GRIPPER'
[INFO] [WallTime: 1437375152.688621] 'Please take it from my gripper'
[INFO] [WallTime: 1437375158.165877] State machine transitioning 'SAY_OPEN_GRIPPER':'spoken'-->'OPEN_GRIPPER_ON_HANDOVER'
/amigo/handoverdetector_right/toggle_robot2human
[INFO] [WallTime: 1437375188.179245] State machine transitioning 'OPEN_GRIPPER_ON_HANDOVER':'failed'-->'SAY_OPEN_GRIPPER_ANYWAY'
[INFO] [WallTime: 1437375188.179924] 'Please take this from me now'
[INFO] [WallTime: 1437375190.095981] State machine transitioning 'SAY_OPEN_GRIPPER_ANYWAY':'spoken'-->'OPEN_GRIPPER_FALLBACK'
[INFO] [WallTime: 1437375190.096672] State machine transitioning 'OPEN_GRIPPER_FALLBACK':'succeeded'-->'CLOSE_GRIPPER_HANDOVER'
[INFO] [WallTime: 1437375190.097175] State machine transitioning 'CLOSE_GRIPPER_HANDOVER':'succeeded'-->'RESET_ARM'
[INFO] [WallTime: 1437375192.910943] State machine transitioning 'RESET_ARM':'succeeded'-->'RESET_TORSO'
[INFO] [WallTime: 1437375192.911675] State machine transitioning 'RESET_TORSO':'done'-->'UNLOCK_ARM'
[INFO] [WallTime: 1437375192.912078] locking_designator LockingDesignator(LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>)) is going to unlock from <robot_ski
[INFO] [WallTime: 1437375192.912329] State machine terminating 'UNLOCK_ARM':'unlocked':'succeeded'
[INFO] [WallTime: 1437375192.912570] State machine terminating 'HANDOVER_NEWSPAPER':'succeeded':'container_succeeded'
[INFO] [WallTime: 1437375192.914348] State machine transitioning 'WAKEUP_CONTAINER':'container_succeeded'-->'CANCEL_HEAD_GOALS_1'
[WAKE ME UP] CancelHeadGoals
[INFO] [WallTime: 1437375192.915345] State machine transitioning 'CANCEL_HEAD_GOALS_1':'done'-->'RECONFIGURE_ED2'
[INFO] [WallTime: 1437375194.003933] State machine transitioning 'RECONFIGURE_ED2':'done'-->'TAKE_ORDER_CONTAINER'
[INFO] [WallTime: 1437375194.004537] State machine starting in initial state 'COUNTER' with userdata: 
    []
[INFO] [WallTime: 1437375194.004875] State machine transitioning 'COUNTER':'counted'-->'SAY_WHAT_BREAKFAST'
[INFO] [WallTime: 1437375194.005279] 'What would you like to have for breakfast?'
[INFO] [WallTime: 1437375196.309309] State machine transitioning 'SAY_WHAT_BREAKFAST':'spoken'-->'GET_ORDER'
[WAKE ME UP] GetOrder
[WAKE ME UP] KeyError resolving: 'beginning'
[WAKE ME UP] KeyError resolving: 'preposition'
[WAKE ME UP] What was heard:      papaya_milk
[WAKE ME UP] Could not get a match with word_item1 = 
[WAKE ME UP] Could not get a match with word_item2 = 
[WAKE ME UP] papaya_milk its a milk!
[WAKE ME UP] papaya_milk its a milk!
[WAKE ME UP] papaya_milk its a milk!
[WAKE ME UP] Third item Milk
[WAKE ME UP] Response: fruit = , cereal =  , milk = papaya_milk
[WAKE ME UP] One of the food types was empty
[INFO] [WallTime: 1437375209.819441] State machine transitioning 'GET_ORDER':'failed'-->'SAY_INCORRECT_ORDER'
[INFO] [WallTime: 1437375209.819937] 'I didn't get that.'
[INFO] [WallTime: 1437375209.822736] State machine transitioning 'SAY_INCORRECT_ORDER':'spoken'-->'COUNTER'
[INFO] [WallTime: 1437375209.823114] State machine transitioning 'COUNTER':'counted'-->'SAY_WHAT_BREAKFAST'
[INFO] [WallTime: 1437375209.823555] 'What do you want to eat?'
[INFO] [WallTime: 1437375212.884825] State machine transitioning 'SAY_WHAT_BREAKFAST':'spoken'-->'GET_ORDER'
[WAKE ME UP] GetOrder
[WAKE ME UP] KeyError resolving: 'beginning'
[WAKE ME UP] KeyError resolving: 'item3'
[WAKE ME UP] KeyError resolving: 'preposition'
[WAKE ME UP] What was heard:      
[WAKE ME UP] Could not get a match with word_item1 = 
[WAKE ME UP] Could not get a match with word_item2 = 
[WAKE ME UP] Response: fruit = , cereal =  , milk = pure_milk
[WAKE ME UP] One of the food types was empty
[INFO] [WallTime: 1437375217.569328] State machine transitioning 'GET_ORDER':'failed'-->'SAY_INCORRECT_ORDER'
[INFO] [WallTime: 1437375217.569759] 'I didn't get that.'
[INFO] [WallTime: 1437375217.572143] State machine transitioning 'SAY_INCORRECT_ORDER':'spoken'-->'COUNTER'
[INFO] [WallTime: 1437375217.572612] State machine transitioning 'COUNTER':'counted'-->'SAY_WHAT_BREAKFAST'
[INFO] [WallTime: 1437375217.573090] 'Please tell me your breakfast order.'
[INFO] [WallTime: 1437375221.435832] State machine transitioning 'SAY_WHAT_BREAKFAST':'spoken'-->'GET_ORDER'
[WAKE ME UP] GetOrder
[WAKE ME UP] KeyError resolving: 'beginning'
[WAKE ME UP] KeyError resolving: 'preposition'
[WAKE ME UP] What was heard:      pure_milk
[WAKE ME UP] Could not get a match with word_item1 = 
[WAKE ME UP] Could not get a match with word_item2 = 
[WAKE ME UP] pure_milk its a milk!
[WAKE ME UP] pure_milk its a milk!
[WAKE ME UP] pure_milk its a milk!
[WAKE ME UP] Third item Milk
[WAKE ME UP] Response: fruit = , cereal =  , milk = pure_milk
[WAKE ME UP] One of the food types was empty
[INFO] [WallTime: 1437375227.073384] State machine transitioning 'GET_ORDER':'failed'-->'SAY_INCORRECT_ORDER'
[INFO] [WallTime: 1437375227.073930] 'I didn't get that.'
[INFO] [WallTime: 1437375227.076725] State machine transitioning 'SAY_INCORRECT_ORDER':'spoken'-->'COUNTER'
[INFO] [WallTime: 1437375227.077211] State machine transitioning 'COUNTER':'limit_reached'-->'SAY_ILL_CHOOSE_BREAKFAST'
[INFO] [WallTime: 1437375227.077715] 'I couldn't understand the breakfast order. I'll choose something for you.'
[INFO] [WallTime: 1437375227.080075] State machine transitioning 'SAY_ILL_CHOOSE_BREAKFAST':'spoken'-->'PICK_DEFAULT_ORDER'
[INFO] [WallTime: 1437375227.080521] State machine transitioning 'PICK_DEFAULT_ORDER':'done'-->'SAY_DEFAULT_ORDER'
[INFO] [WallTime: 1437375227.080906] 'I will bring you a lemon, coconut cereals and pure milk'
[INFO] [WallTime: 1437375237.077346] State machine terminating 'SAY_DEFAULT_ORDER':'spoken':'container_succeeded'
[INFO] [WallTime: 1437375237.077867] State machine transitioning 'TAKE_ORDER_CONTAINER':'container_succeeded'-->'GOTO_KITCHEN_CONTAINER'
[INFO] [WallTime: 1437375237.078304] State machine starting in initial state 'SAY_PREPARING' with userdata: 
    []
[INFO] [WallTime: 1437375237.078747] 'I'm going to the kitchen'
[INFO] [WallTime: 1437375237.081255] State machine transitioning 'SAY_PREPARING':'spoken'-->'GOTO_KITCHEN'
[INFO] [WallTime: 1437375237.081829] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375237.085138] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375237.085566] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375237.198184] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437375237.271054] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437375237.293361] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f8487cf8>
[INFO] [WallTime: 1437375237.293808] 'I will go there right away!'
[INFO] [WallTime: 1437375237.296590] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375254.312458] State machine transitioning 'EXECUTE_PLAN':'blocked'-->'PLAN_BLOCKED'
[INFO] [WallTime: 1437375254.312998] Plan blocked
[WARN] [WallTime: 1437375255.315192] Plan free again
[INFO] [WallTime: 1437375255.315542] State machine transitioning 'PLAN_BLOCKED':'free'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375266.328015] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375266.328447] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375266.332504] 

Navigation summary:
Covered 9.76268846163 meters in 29.2472391129 seconds (0.333798633914) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375266.332863] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375266.333162] State machine terminating 'GOTO_KITCHEN':'arrived':'container_succeeded'
[INFO] [WallTime: 1437375266.333440] State machine transitioning 'GOTO_KITCHEN_CONTAINER':'container_succeeded'-->'PREP_BREAKFAST_CONTAINER'
[INFO] [WallTime: 1437375266.333880] State machine starting in initial state 'SAY_PREPARING' with userdata: 
    []
[INFO] [WallTime: 1437375266.334200] 'I'm going to prepare your breakfast. La la la la la'
[INFO] [WallTime: 1437375266.336825] State machine transitioning 'SAY_PREPARING':'spoken'-->'SELECT_ITEM'
asked items: ['coconut_cereals', 'pure_milk', 'lemon']
category items: ['papaya_milk', 'pure_milk']
[INFO] [WallTime: 1437375266.337336] 'I will get your milk now.'
[INFO] [WallTime: 1437375266.340003] State machine transitioning 'SELECT_ITEM':'selected'-->'GOTO_ITEM'
[INFO] [WallTime: 1437375266.340517] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375266.343641] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375266.344075] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375266.456001] choosing best entity from this list (name->weight):
    [('kitchentable', 0)]
[INFO] [WallTime: 1437375266.465376] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437375266.572672] choosing best entity from this list (name->weight):
    [('kitchentable', 0)]
[INFO] [WallTime: 1437375266.594384] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84d5710>
[INFO] [WallTime: 1437375266.594922] 'Getting there!'
[INFO] [WallTime: 1437375266.597649] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375277.609779] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375277.610339] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375277.613727] 

Navigation summary:
Covered 1.95725830627 meters in 11.2699429989 seconds (0.173670648242) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375277.614069] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375277.614343] State machine transitioning 'GOTO_ITEM':'arrived'-->'FIND_ITEM'
[INFO] [WallTime: 1437375277.631617] choosing best entity from this list (name->weight):
    [('kitchentable', 0)]
result_type =  pure_milk
[INFO] [WallTime: 1437375277.631935] Look at x: 0.0 y: 0.0 z: 0.769999980927 in frame /kitchentable
look at table, point_stamped =  header: 
  seq: 0
  stamp: 
    secs: 0
    nsecs: 0
  frame_id: /kitchentable
point: 
  x: 0.0
  y: 0.0
  z: 0.769999980927
entity_ids 1:  ['2db47115dd2da33056da3ba1030c1f04', '365aa12feec12a19d059e07dde2152c9', '3fcc2ac100138680c35e48ff3017670a', '5d9282e0f63f275486a51120ab114669', '73e71a6ddbbdfd05522d4ddfe48fcee3', '7c6973b74cbc34d073ecbebeec6547fb', 'cb84da9b8c830c352105cb7ce8907954']
ja, toegevoegd
ja, toegevoegd
filtered_ids = ['3fcc2ac100138680c35e48ff3017670a', '7c6973b74cbc34d073ecbebeec6547fb']
self.items_were_looking_for = ['papaya_milk', 'pure_milk']
I found the following items: ['papaya_milk', 'pure_milk']
[INFO] [WallTime: 1437375280.808210] State machine transitioning 'FIND_ITEM':'item_found'-->'PICK_UP_ITEM'
[INFO] [WallTime: 1437375280.808942] State machine starting in initial state 'PREPARE_GRASP' with userdata: 
    []
[INFO] [WallTime: 1437375280.809211] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375289.230484] State machine transitioning 'PREPARE_GRASP':'succeeded'-->'NAVIGATE_TO_GRAB'
[INFO] [WallTime: 1437375289.231293] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375289.234737] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375289.235142] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375289.335678] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375289.336090] Navigating to grasp entity id:7c6973b74cbc34d073ecbebeec6547fb
[INFO] [WallTime: 1437375289.355435] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84e5050>
[INFO] [WallTime: 1437375289.356006] 'I'm on my way!'
[INFO] [WallTime: 1437375289.359381] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375292.362520] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375292.362980] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375292.366643] 

Navigation summary:
Covered 0.243430731446 meters in 3.13177800179 seconds (0.0777292424008) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375292.367057] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375292.367371] State machine transitioning 'NAVIGATE_TO_GRAB':'arrived'-->'GRAB'
[INFO] [WallTime: 1437375292.367843] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375292.368105] PickUp!
[INFO] [WallTime: 1437375292.456066] x: 0.638381049249
y: -0.18430227138
z: 0.846716046333
[INFO] [WallTime: 1437375292.456608] Starting Pre-grasp
[INFO] [WallTime: 1437375312.920225] y_home = -0.2
[INFO] [WallTime: 1437375312.920625] start moving to carrying pose
[INFO] [WallTime: 1437375312.920894] Grasp precompute frame id = /amigo/base_link
[INFO] [WallTime: 1437375317.329249] State machine terminating 'GRAB':'succeeded':'done'
[INFO] [WallTime: 1437375317.329631] State machine transitioning 'PICK_UP_ITEM':'done'-->'GOTO_TABLE'
[INFO] [WallTime: 1437375317.330163] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375317.333363] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375317.333814] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375317.446718] choosing best entity from this list (name->weight):
    [('livingroom', 0)]
[INFO] [WallTime: 1437375317.459862] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
[INFO] [WallTime: 1437375317.579046] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
[INFO] [WallTime: 1437375317.602451] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84873b0>
[INFO] [WallTime: 1437375317.603049] 'I'm on my way!'
[INFO] [WallTime: 1437375317.605951] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375330.619908] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375330.620449] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375330.624379] 

Navigation summary:
Covered 3.75696882808 meters in 13.290886879 seconds (0.282672545654) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375330.624728] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375330.625039] State machine transitioning 'GOTO_TABLE':'arrived'-->'SCAN_TABLE'
[INFO] [WallTime: 1437375330.640923] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
[INFO] [WallTime: 1437375330.641366] Look at x: 0.0 y: 0.0 z: 0.774999976158 in frame /dinnertable
[INFO] [WallTime: 1437375331.243570] State machine transitioning 'SCAN_TABLE':'done'-->'PLACE_ITEM'
[INFO] [WallTime: 1437375331.244129] State machine starting in initial state 'NAVIGATE_TO_PLACE' with userdata: 
    []
[INFO] [WallTime: 1437375331.244471] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375331.247236] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375331.247661] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375331.348162] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375331.369355] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
Distance: 60
Distance: 75
Distance: 81
Distance: 84
Distance: 87
Distance: 91
Distance: 110
Distance: 10000000000
Distance: 10000000000
Distance: 137
Distance: 135
Distance: 135
Distance: 136
Distance: 138
Distance: 138
Distance: 10000000000
Distance: 8
Distance: 26
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 58
Distance: 58
[INFO] [WallTime: 1437375332.239530] Placement = header:    seq: 0   stamp:      secs: 1437375331     nsecs: 370484113   frame_id: /map pose:    position:      x: 7.36998829363     y: 0.739834005109     z: 0.774999976158   orientation:      x: 0.0     y: 0.0     z: 0.0     w: 1.0
[INFO] [WallTime: 1437375332.239956] Navigating to place at header:    seq: 0   stamp:      secs: 1437375331     nsecs: 370484113   frame_id: /map pose:    position:      x: 7.36998829363     y: 0.739834005109     z: 0.774999976158   orientation:      x: 0.0     y: 0.0     z: 0.0     w: 1.0
[INFO] [WallTime: 1437375332.255070] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84a4ef0>
[INFO] [WallTime: 1437375332.255568] 'I'm on my way!'
[INFO] [WallTime: 1437375332.258269] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375336.262436] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375336.262869] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375336.270716] 

Navigation summary:
Covered 0.351999596627 meters in 5.02335500717 seconds (0.0700726100634) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375336.271204] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375336.271520] State machine transitioning 'NAVIGATE_TO_PLACE':'arrived'-->'PUT'
[INFO] [WallTime: 1437375336.287138] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
Distance: 54
Distance: 75
Distance: 81
Distance: 84
Distance: 87
Distance: 91
Distance: 110
Distance: 116
Distance: 134
Distance: 132
Distance: 132
Distance: 133
Distance: 135
Distance: 135
Distance: 137
Distance: 140
Distance: 4
Distance: 2
Distance: 26
Distance: 10000000000
Distance: 10000000000
Distance: 43
Distance: 43
Distance: 45
Distance: 47
Distance: 48
Distance: 50
Distance: 53
[INFO] [WallTime: 1437375337.163152] Placement = header:    seq: 0   stamp:      secs: 1437375336     nsecs: 287892103   frame_id: /map pose:    position:      x: 7.36995773892     y: 0.889834001997     z: 0.774999976158   orientation:      x: 0.0     y: 0.0     z: 0.0     w: 1.0
[INFO] [WallTime: 1437375337.163528] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375337.163863] Placing
[INFO] [WallTime: 1437375374.002149] State machine terminating 'PUT':'succeeded':'done'
[INFO] [WallTime: 1437375374.002571] State machine transitioning 'PLACE_ITEM':'done'-->'ADD_POSITIVE_RESULT'
milk
[INFO] [WallTime: 1437375374.002983] State machine transitioning 'ADD_POSITIVE_RESULT':'done'-->'SELECT_ITEM'
asked items: ['coconut_cereals', 'pure_milk', 'lemon']
category items: ['apple', 'lemon', 'pear']
[INFO] [WallTime: 1437375374.003448] 'I will get your fruit now.'
[INFO] [WallTime: 1437375374.005936] State machine transitioning 'SELECT_ITEM':'selected'-->'GOTO_ITEM'
[INFO] [WallTime: 1437375374.006474] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375374.009298] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375374.009735] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375374.123215] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437375374.133304] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437375374.176095] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437375374.200944] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84e5b90>
[INFO] [WallTime: 1437375374.201557] 'Getting there!'
[INFO] [WallTime: 1437375374.204344] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375390.220754] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375390.221472] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375390.224919] 

Navigation summary:
Covered 4.67265306067 meters in 16.2154798508 seconds (0.288160023858) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375390.225268] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375390.225577] State machine transitioning 'GOTO_ITEM':'arrived'-->'FIND_ITEM'
[INFO] [WallTime: 1437375390.235366] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
result_type =  lemon
[INFO] [WallTime: 1437375390.235696] Look at x: 0.0 y: 0.0 z: 0.735000014305 in frame /kitchencounter
look at table, point_stamped =  header: 
  seq: 0
  stamp: 
    secs: 0
    nsecs: 0
  frame_id: /kitchencounter
point: 
  x: 0.0
  y: 0.0
  z: 0.735000014305
entity_ids 1:  ['257b8a56b637d22e50022a1adf367d2a', '295b3b1f147f79dd9efc91760ac87e3a', '7bfb2b0ee42a73184426e292f5ea44ec', '885c37b5c243c216103a2a034ccbbf53', 'fe729808d32464ca8e171aa008b4da1d']
ja, toegevoegd
ja, toegevoegd
ja, toegevoegd
ja, toegevoegd
filtered_ids = ['257b8a56b637d22e50022a1adf367d2a', '295b3b1f147f79dd9efc91760ac87e3a', '7bfb2b0ee42a73184426e292f5ea44ec', '885c37b5c243c216103a2a034ccbbf53']
self.items_were_looking_for = ['apple', 'lemon', 'pear']
I found the following items: ['', '', '', 'lemon']
[INFO] [WallTime: 1437375394.498673] State machine transitioning 'FIND_ITEM':'item_found'-->'PICK_UP_ITEM'
[INFO] [WallTime: 1437375394.499188] State machine starting in initial state 'PREPARE_GRASP' with userdata: 
    []
[INFO] [WallTime: 1437375394.499475] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375402.918919] State machine transitioning 'PREPARE_GRASP':'succeeded'-->'NAVIGATE_TO_GRAB'
[INFO] [WallTime: 1437375402.919485] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375402.922811] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375402.923245] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375403.023728] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375403.024130] Navigating to grasp entity id:885c37b5c243c216103a2a034ccbbf53
[INFO] [WallTime: 1437375403.039390] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f852a4d0>
[INFO] [WallTime: 1437375403.040099] 'Getting there!'
[INFO] [WallTime: 1437375403.042942] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375408.049407] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375408.049848] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375408.053696] 

Navigation summary:
Covered 0.497973586194 meters in 5.13074421883 seconds (0.0970567942885) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375408.054055] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375408.054338] State machine transitioning 'NAVIGATE_TO_GRAB':'arrived'-->'GRAB'
[INFO] [WallTime: 1437375408.054616] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375408.054815] PickUp!
[INFO] [WallTime: 1437375408.136836] x: 0.587660284081
y: -0.252842959308
z: 0.7731590271
[INFO] [WallTime: 1437375408.137325] Starting Pre-grasp
[INFO] [WallTime: 1437375427.409516] y_home = -0.2
[INFO] [WallTime: 1437375427.409888] start moving to carrying pose
[INFO] [WallTime: 1437375427.410166] Grasp precompute frame id = /amigo/base_link
[INFO] [WallTime: 1437375431.324694] State machine terminating 'GRAB':'succeeded':'done'
[INFO] [WallTime: 1437375431.325068] State machine transitioning 'PICK_UP_ITEM':'done'-->'GOTO_TABLE'
[INFO] [WallTime: 1437375431.327931] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375431.331082] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375431.331495] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375431.441108] choosing best entity from this list (name->weight):
    [('livingroom', 0)]
[INFO] [WallTime: 1437375431.455469] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
[INFO] [WallTime: 1437375431.573484] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
[INFO] [WallTime: 1437375431.595762] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84e5320>
[INFO] [WallTime: 1437375431.596219] 'I'm on my way!'
[INFO] [WallTime: 1437375431.599039] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375461.630921] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375461.631353] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375461.634676] 

Navigation summary:
Covered 4.87921614454 meters in 30.3034479618 seconds (0.161011913585) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375461.635028] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375461.635315] State machine transitioning 'GOTO_TABLE':'arrived'-->'SCAN_TABLE'
[INFO] [WallTime: 1437375461.654916] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
[INFO] [WallTime: 1437375461.655375] Look at x: 0.0 y: 0.0 z: 0.774999976158 in frame /dinnertable
[INFO] [WallTime: 1437375462.240020] State machine transitioning 'SCAN_TABLE':'done'-->'PLACE_ITEM'
[INFO] [WallTime: 1437375462.240612] State machine starting in initial state 'NAVIGATE_TO_PLACE' with userdata: 
    []
[INFO] [WallTime: 1437375462.240956] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375462.244064] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375462.244496] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375462.345019] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375462.360467] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
Distance: 60
Distance: 75
Distance: 81
Distance: 84
Distance: 87
Distance: 91
Distance: 10000000000
Distance: 10000000000
Distance: 137
Distance: 135
Distance: 136
Distance: 136
Distance: 136
Distance: 137
Distance: 139
Distance: 141
Distance: 7
Distance: 26
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 10000000000
Distance: 62
Distance: 59
[INFO] [WallTime: 1437375463.200710] Placement = header:    seq: 0   stamp:      secs: 1437375462     nsecs: 361382007   frame_id: /map pose:    position:      x: 7.36998829363     y: 0.739834005109     z: 0.774999976158   orientation:      x: 0.0     y: 0.0     z: 0.0     w: 1.0
[INFO] [WallTime: 1437375463.201197] Navigating to place at header:    seq: 0   stamp:      secs: 1437375462     nsecs: 361382007   frame_id: /map pose:    position:      x: 7.36998829363     y: 0.739834005109     z: 0.774999976158   orientation:      x: 0.0     y: 0.0     z: 0.0     w: 1.0
[INFO] [WallTime: 1437375463.217105] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84d5518>
[INFO] [WallTime: 1437375463.217761] 'I will go there right away!'
[INFO] [WallTime: 1437375463.221795] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375467.225826] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375467.226267] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375467.233520] 

Navigation summary:
Covered 0.331315061886 meters in 4.98930382729 seconds (0.0664050683932) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375467.233939] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375467.234240] State machine transitioning 'NAVIGATE_TO_PLACE':'arrived'-->'PUT'
[INFO] [WallTime: 1437375467.247374] choosing best entity from this list (name->weight):
    [('dinnertable', 0)]
Distance: 54
Distance: 75
Distance: 81
Distance: 84
Distance: 87
Distance: 91
Distance: 110
Distance: 116
Distance: 134
Distance: 133
Distance: 133
Distance: 133
Distance: 135
Distance: 135
Distance: 138
Distance: 10000000000
Distance: 1
Distance: 26
Distance: 10000000000
Distance: 10000000000
Distance: 42
Distance: 42
Distance: 45
Distance: 47
Distance: 48
Distance: 50
Distance: 53
[INFO] [WallTime: 1437375468.089423] Placement = header:    seq: 0   stamp:      secs: 1437375467     nsecs: 248835086   frame_id: /map pose:    position:      x: 7.36998829363     y: 0.739834005109     z: 0.774999976158   orientation:      x: 0.0     y: 0.0     z: 0.0     w: 1.0
[INFO] [WallTime: 1437375468.089855] LockingDesignator(<robot_smach_states.util.designators.designator.ArmDesignator object at 0x7fe8f85ef290>) resolved to <robot_ski, but is *not locked* to it
[INFO] [WallTime: 1437375468.090176] Placing
[INFO] [WallTime: 1437375504.852114] State machine terminating 'PUT':'succeeded':'done'
[INFO] [WallTime: 1437375504.852535] State machine transitioning 'PLACE_ITEM':'done'-->'ADD_POSITIVE_RESULT'
fruit
[INFO] [WallTime: 1437375504.852953] State machine transitioning 'ADD_POSITIVE_RESULT':'done'-->'SELECT_ITEM'
asked items: ['coconut_cereals', 'pure_milk', 'lemon']
category items: ['coconut_cereals', 'coco_balls', 'egg_stars']
[INFO] [WallTime: 1437375504.853449] 'I will get your cereal now.'
[INFO] [WallTime: 1437375504.856251] State machine transitioning 'SELECT_ITEM':'selected'-->'GOTO_ITEM'
[INFO] [WallTime: 1437375504.856784] State machine starting in initial state 'START_ANALYSIS' with userdata: 
    []
[INFO] [WallTime: 1437375504.859759] State machine transitioning 'START_ANALYSIS':'done'-->'NAVIGATE'
[INFO] [WallTime: 1437375504.860212] State machine starting in initial state 'GET_PLAN' with userdata: 
    []
[INFO] [WallTime: 1437375504.972960] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437375504.982367] choosing best entity from this list (name->weight):
    [('kitchen', 0)]
[INFO] [WallTime: 1437375505.067575] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
[INFO] [WallTime: 1437375505.090603] Goal handle = <actionlib.action_client.ClientGoalHandle instance at 0x7fe8f84b1c68>
[INFO] [WallTime: 1437375505.091169] 'Getting there!'
[INFO] [WallTime: 1437375505.094103] State machine transitioning 'GET_PLAN':'goal_ok'-->'EXECUTE_PLAN'
[INFO] [WallTime: 1437375520.110255] State machine terminating 'EXECUTE_PLAN':'succeeded':'arrived'
[INFO] [WallTime: 1437375520.110678] State machine transitioning 'NAVIGATE':'arrived'-->'STOP_ANALYSIS_SUCCEED'
[INFO] [WallTime: 1437375520.113815] 

Navigation summary:
Covered 4.62637603685 meters in 15.253934145 seconds (0.303290678515) m/s avg.
Result = succeeded with 0 plans, 0 clears and 0 resets


[INFO] [WallTime: 1437375520.114153] State machine terminating 'STOP_ANALYSIS_SUCCEED':'done':'arrived'
[INFO] [WallTime: 1437375520.114424] State machine transitioning 'GOTO_ITEM':'arrived'-->'FIND_ITEM'
[INFO] [WallTime: 1437375520.123998] choosing best entity from this list (name->weight):
    [('kitchencounter', 0)]
result_type =  coconut_cereals
[INFO] [WallTime: 1437375520.124339] Look at x: 0.0 y: 0.0 z: 0.735000014305 in frame /kitchencounter
look at table, point_stamped =  header: 
  seq: 0
  stamp: 
    secs: 0
    nsecs: 0
  frame_id: /kitchencounter
point: 
  x: 0.0
  y: 0.0
  z: 0.735000014305
entity_ids 1:  ['08ac6a37ba521e11f7170bc5b795fe6f', '295b3b1f147f79dd9efc91760ac87e3a', '7bfb2b0ee42a73184426e292f5ea44ec']
ja, toegevoegd
ja, toegevoegd
ja, toegevoegd
filtered_ids = ['08ac6a37ba521e11f7170bc5b795fe6f', '295b3b1f147f79dd9efc91760ac87e3a', '7bfb2b0ee42a73184426e292f5ea44ec']
self.items_were_looking_for = ['coconut_cereals', 'coco_balls', 'egg_stars']
I found the following items: ['coco_balls', 'egg_stars', 'egg_stars']
I found the following milk, cereal and fruit items: ['coco_balls', 'egg_stars']
[ERROR] [WallTime: 1437375524.994103] InvalidUserCodeError: Could not execute state 'FIND_ITEM' of type '<wakemeup_states.FindItem object at 0x7fe8f85afe90>': Traceback (most recent call last):
  File "/opt/ros/indigo/lib/python2.7/dist-packages/smach/state_machine.py", line 247, in _update_once
    self._remappings[self._current_label]))
  File "/home/amigo/ros/indigo/repos/https:/github.com/tue-robotics/tue_robocup.git/challenge_wakemeup/src/wakemeup_states.py", line 596, in execute
    self.result_des.current = self.robot.ed.get_entity(found_cereal[0])
  File "/home/amigo/ros/indigo/system/src/robot_smach_states/src/robot_smach_states/util/designators/designator.py", line 168, in _set_current
    raise TypeError("Assigned value does not match resolve_type for {0}. Expected a (subclass of) {1} but got a {2}".format(self, self.resolve_type, type(value)))
TypeError: Assigned value does not match resolve_type for <robot_smach_states.util.designators.designator.VariableDesignator object at 0x7fe8f85efb10>. Expected a (subclass of) <class 'ed.msg._EntityInfo.EntityInfo'> but got a <type 'NoneType'>

[ERROR] [WallTime: 1437375524.994568] State 'PREP_BREAKFAST_CONTAINER' failed to execute.
Exception occurred on state machine execution

